<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Damotorie's World</title>
    <link href="../../CSS/bootstrap.css" rel="stylesheet">
    <link href="../../CSS/bootstrap-theme.css" rel="stylesheet">
    <script src="../../JS/bootstrap.js" type="text/javascript">
    <script src="../../JS/npm.js" type="text/javascript">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-101495030-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../../index.html">Damotorie CTF's</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active"><a href="../../Binary.html">Binary</a></li>
                <li><a href="../../Reversing.html">Reversing</a></li>
                <li><a href="../../ETC.html">ETC</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div>
</nav>
<br>
<br>
<br>
<div class="container col-md-offset-2 col-md-8">
    <div><p><h2>overflow4-2013picoCTF</h2></p><p>이번에는 picoctf에 나온 4번째 오버플로우문제입니다. 이제는 저희가 쉘코드까지 입력해야하는 전형적인 오버플로우 문제가 되었습니다. 어려울게 없는게 NX가 걸려있지 않아서 스택에서 바로 쉘코드를 실행시킬수 있습니다. 따라서 힘들게 ROP을 사용한다던가 Ret2Libc같은 기술을 사용할 필요없이 바로 실행시키기만 하면 됩니다. 유일한 걱정거리가 ASLR인데 실제 대회에서는 ASLR이 꺼진상태로 나온것으로 알고 있습니다. 따라서 오버플로우를 막는 기술이 하나도 적용되지 않은것을 알 수 있습니다.</p><p>먼저 대회와 같은 상황을 만들기위해서 ASLR을 꺼보도록 하겠습니다. 물론 할 수 있다면 ASLR을 키고 하는것이 더 많은 공부가 되겠지만 ASLR을 키고도 쉘을 얻기 위해서는 메모리 릭을 통해서 기준이 되는 주소를 찾을 필요가 있는데 어떻게해도 메모리를 릭시킬 방법을 못찾았습니다. 그래서 그냥 ASLR을 끄고 해결하는 것만 해보도록 하겠습니다. ASLR을 끄는 명령어는 <code>sudo sysctl -w kernel.randomize_va_space=0</code>입니다(<code>Linux ubuntu 16.04 LTS</code>기준) 그리고 프로그램을 실행시켜보면 착하게도 스택의 모양을 출력해줍니다. 저희가 문제를 풀 방법은 먼저 쉘코드를 입력해줍니다. 그리고 <code>eip</code>를 변조시켜야 하는데 그렇기 위해서는 쉘코드가 끝난뒤 <code>eip</code>가 저장된 위치까지의 사이 길이만큼을 <code>a</code>로 채워줍니다. 쉘코드를 찾는것은 구글에 검색하면 많이 나옵니다. 32비트 컴퓨터용 프로그램이라는 것을 주의하시고 찾아보세요. 그렇게 하면 쉽게 푸실수 있을것입니다.</p><p>혹시 모르는부분이나 틀린부분이 있다면 메일보내주세요.
</p></div>
</div>
</body>
</html>